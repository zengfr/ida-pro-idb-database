基于code lifting的二进制差异消除

https://zhuanlan.zhihu.com/p/341448835

我把这种编译器带来的二进制差异叫做编译器噪声。

解决这个问题的价值
那么这个问题描述清楚了，解决它有什么价值呢？

相似度比较是样本聚类的基础，聚类是任何一家做文件检测的公司的基础手段。而好的聚类需要消除编译器噪声。
函数签名同样是基础能力，基于函数签名做软件成分分析，这样可以识别程序是否包含有漏洞的Lib库。基于函数签名还可以做样本家族分析，同源性分析等。函数签名同样需要消除编译器噪声。
解决这个问题的思路
我们思考前面的例子，二进制文件是从同一份源码编译而来。在源码层面上完全一致，差异体现在X86指令代码上。产生这种差异在于，从源码到二进制，经历了Arch的选择，compiler的选择，compiler不同option的选择，compiler不同version的选择。每一个选择的结果，都会对生成的二进制文件造成影响。常规比较二进制相似度的方法，无非就是定义和抽取一组特征，特征向量化，向量求距离。可抽取的特征包括：

文件格式特征，导入导出表，节特征。
字符串等资源的特征。
代码段比较（可以只取操作码，不取操作数）
构建函数的CFG，将二进制比较问题转换为图比较问题。
函数粒度的比较，除了全代码比较，opcode比较，CFG比较外，似乎也没有别的信息可用了。然而这都解决不了编译器噪声问题。



前面说了，造成差异的根本在于从源码经过很多可选项后生成了二进制文件，这本质上是形式转换，形式转换的过程中产生了差异。那么如果形式再转换回去，是否可以消除差异呢？所谓转换回去就是反编译。既然在X86指令这层差异明显，那么回到某种IR，甚至是C源码这层，差异的表现是怎样的呢？

看起来，解决这个问题需要先考虑反编译的问题。反编译是很难的一件事，表现在：

二进制文件在形态上是机器指令的序列，进行反汇编是很容易的。然而，X86汇编是没有类型信息的，高级语言的数组，结构，枚举等信息在汇编上已经不存在。
源码的语法结构信息也是丢失的。不管上层是 switch 还是 for还是goto造成的逻辑结构，到了汇编这里都是jmp。
现代化的编译器很有多很强大的优化技术，经过层层优化后还原源码是不可能的。
越是高级的语言，编译器的预处理做的工作就更多，比如C++的模板展开。
汇编到IR会产生代码膨胀（IDA把x86变成它的micro code体积膨胀5倍），IR到C，需要重建CFG。这个CFG是很大的，需要高级的剪枝技术。（类似于优化技术）


如上是难点，应该还有很多更具体的难点我没有列出来。不过也有好消息：

我们只是让X86汇编lift到某种IR，C源码可以理解为最高层的IR，但是我们基本不需要还原到C，在中间态消除差异即可。
我们有LLVM这个强大的工具链可以用。